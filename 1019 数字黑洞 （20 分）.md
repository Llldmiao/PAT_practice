# 1019 数字黑洞 （20 分）

给定任一个各位数字不完全相同的 4 位正整数，如果我们先把 4 个数字按非递增排序，再按非递减排序，然后用第 1 个数字减第 2 个数字，将得到一个新的数字。一直重复这样做，我们很快会停在有“数字黑洞”之称的 `6174`，这个神奇的数字也叫 Kaprekar 常数。

例如，我们从`6767`开始，将得到

```
7766 - 6677 = 1089
9810 - 0189 = 9621
9621 - 1269 = 8352
8532 - 2358 = 6174
7641 - 1467 = 6174
... ...
```

现给定任意 4 位正整数，请编写程序演示到达黑洞的过程。

### 输入格式：

输入给出一个 (0,104) 区间内的正整数 N。

### 输出格式：

如果 N 的 4 位数字全相等，则在一行内输出 `N - N = 0000`；否则将计算的每一步在一行内输出，直到 `6174` 作为差出现，输出格式见样例。注意每个数字按 `4` 位数格式输出。

### 输入样例 1：

```in
6767
```

### 输出样例 1：

```out
7766 - 6677 = 1089
9810 - 0189 = 9621
9621 - 1269 = 8352
8532 - 2358 = 6174
```

### 输入样例 2：

```in
2222
```

### 输出样例 2：

```out
2222 - 2222 = 0000
```

### 解题：

用什么存数字？数组还是变量？简单一点吧，变量

```c
#include<stdio.h>
#include<stdlib.h>
int comp(const void *a,const void *b){
  return *(int*)a- *(int*)b;
}
int main(){
  int N;
  scanf("%d",&N);
  int n[4];
  int max,min,k=0;
 /*此处用do...while原因
 如果输入为6174,还是需要计算一步，如果用while循环的话会直接跳出去
 */
 do{
   n[0]=N/1000;
   n[1]=N/100%10;
   n[2]=N/10%10;
   n[3]=N%10;
   qsort(n,4,sizeof(int),comp);
   min=n[0]*1000+n[1]*100+n[2]*10+n[3];
   max=n[3]*1000+n[2]*100+n[1]*10+n[0];
   N=max-min;
   printf("%04d - %04d = %04d\n",max,min,N);
 }while(N!=6174 && N!=0)
 
 return 0;
}
```

