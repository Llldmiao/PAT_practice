# 1008 数组元素循环右移问题 （20 分）

一个数组A中存有N（>0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（≥0）个位置，即将A中的数据由（A0A1⋯AN−1）变换为（AN−M⋯AN−1A0A1⋯AN−M−1）（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数据的次数尽量少 ，要如何设计移动的方法？

### 输入格式:

每个输入包含一个测试用例，第1行输入N（1≤N≤100）和M（≥0）；第2行输入N个整数，之间用空格分隔。

### 输出格式:

在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。

### 输入样例:

```in
6 2
1 2 3 4 5 6
```

### 输出样例:

```out
5 6 1 2 3 4
```

---

### 解题

~~难受啊兄弟，这道题做了快四小时~~

```c
#include<stdio.h>
int main(){
  int N ,M ,a[101]={0};
  scanf("%d%d",&N,&M);
  M %=N;                    //M可能比N大，自主解题时未考虑到
  for(int i=0 ;i<N ;i++){   //读入数组
    scanf("%d",&a[i]);
  }
  /*mmp 直接输出不好吗  写了这么多 结果还有一个测试点答案错误。。。呜呜呜  被自己蠢哭
  if(M!=0)
  for(int i=0 ;i<M ;i++){
    int temp1=a[i],i0=i,temp2; /*temp1记录第一个取出点的移动前的值（由于移动值），
                                 temp2记录第二个取出点的移动前的值（由于记录值）
                                 i0保存本次循环中i的初始值
                                * /
    a[i0]=a[N+i0-M];           //a[N+i0-M]的值向右移动M个位置后落在a[i0]处
    while((i+M-N) != i0){      //没有回到起始位置i0时
      if((i+M) <=(N-1)){       //若向右移动M个位置后还在数组长度范围内
        i = i+M;
        temp2 = a[i];        //记录右移后位置原本的值
        a[i] = temp1;        //将右移的值放入右移后的位置
        temp1 = temp2;         
        
      }
      else{                   //若右移M个位置后超出数组长度
        i = i+M-N;
        temp2 = a[i];
        a[i] = temp1;
        temp1 = temp2;
      }
    }
    
    i = i0;               //恢复i在本次循环中的初始值
  }
  
  //输出移动后的数组
  for(int i=0 ;i<N-1 ;i++){
    printf("%d ",a[i]);
  }
  printf("%d",a[N-1]);
  */
    
    
  //输出
  for(int i = N-M ;i <N ;i++)
  {
    printf("%d ",a[i]);
  }
  for(int i = 0;i <N-M-1 ;i++)
  {
    printf("%d ",a[i]);
  }
  printf("%d",a[N-M-1]);
    
  return 0;
}

```

